---
title: "Announcing Rust GPU 0.10"
slug: rust-gpu-0.10
tags: ["announcement", "release"]
draft: true
---

# Announcing Rust GPU 0.10

The Rust GPU maintainers are happy to announce a new version of [Rust
GPU](https://github.com/rust-gpu/rust-gpu), 0.10. Rust GPU makes it possible to write
and run GPU software in Rust.

This release is our first as a [community-owned project](/blog/transition-announcement).
One of our goals is to move releases to a more frequent and rapid pace—the last release
was on July 25, 2023!

We're eager to add more users and contributors. To follow along or get involved, check out the [`rust-gpu` repo on GitHub](https://github.com/rust-gpu/rust-gpu).

<!-- truncate -->

## What's new in 0.10

### Update Rust requirement to a modern version

Rust GPU includes a compiler backend that compiles regular Rust code into
[SPIR-V](https://www.khronos.org/spir/), a low-level format that [most GPUs
understand](https://vulkan.gpuinfo.org/). Because of this deep integration with compiler
internals, Rust GPU must use a very specific version of the Rust compiler. Rust GPU now
supports `nightly-2024-11-22` (up from the ancient `nightly-2023-05-27`). This roughly
corresponds to [Rust 1.83](https://blog.rust-lang.org/2024/11/28/Rust-1.83.0.html).

:::tip

Most real-world projects like [`krnl`](https://github.com/charles-r-earp/krnl) and
[`renderling`](https://github.com/schell/renderling) compile their GPU code with Rust
GPU's specific version of nightly while using stable Rust for the rest of their code. We
are in the process of making this workflow much easier.

:::

Updating to a newer nightly version required heroic effort from
[@eddyb](https://github.com/eddyb), as significant breaking changes to Rust's [internal
allocation model](https://github.com/rust-lang/rust/pull/122053) and
[`#[repr(simd)]`](https://github.com/rust-lang/rust/pull/129403) were introduced in
`rustc`. [@eddyb](https://github.com/eddyb) was able to [vendor in parts of `rustc` and
patch out others](https://github.com/Rust-GPU/rust-gpu/pull/170), unblocking the update
and buying us time to [figure out the best way
forward](https://github.com/Rust-GPU/rust-gpu/issues/182).

Rust GPU is an "out-of-tree" compiler backend. This enables fast iteration while we
explore the problem space, but also makes us more susceptible to this sort of breakage.
One of our long-term goals is to be a supported `rustc` backend.

### **Mesh shader support**

Rust GPU maintainer [@Firestar99](https://github.com/firestar99) and contributor
[@BeastLe9enD](https://github.com/BeastLe9enD) added support for [mesh
shaders](https://github.com/Rust-GPU/rust-gpu/pull/44).

[Mesh shaders](https://www.khronos.org/blog/mesh-shading-for-vulkan) are a modern GPU
feature that replace traditional vertex and geometry shaders. They give GPU developers
more control over the entire pipeline by letting them directly process batches of
vertices and primitives in compute-like shaders. This allows for more efficient culling,
level-of-detail calculations, and custom pipeline logic—all on the GPU.

An example of a Rust GPU mesh shader that outputs a triangle:

```
use spirv_std::arch::set_mesh_outputs_ext;
use spirv_std::glam::{UVec3, Vec4};
use spirv_std::spirv;

#[spirv(mesh_ext(
    threads(1),
    output_vertices = 3,
    output_primitives_ext = 1,
    output_triangles_ext
))]
pub fn main(
    #[spirv(position)] positions: &mut [Vec4; 3],
    #[spirv(primitive_triangle_indices_ext)] indices: &mut [UVec3; 1],
) {
    unsafe {
        set_mesh_outputs_ext(3, 1);
    }

    positions[0] = Vec4::new(-0.5, 0.5, 0.0, 1.0);
    positions[1] = Vec4::new(0.5, 0.5, 0.0, 1.0);
    positions[2] = Vec4::new(0.0, -0.5, 0.0, 1.0);

    indices[0] = UVec3::new(0, 1, 2);
}
```

An example of a Rust GPU mesh task shader:

```
use spirv_std::arch::emit_mesh_tasks_ext;
use spirv_std::spirv;

#[spirv(task_ext(threads(1)))]
pub fn main() {
    unsafe {
        emit_mesh_tasks_ext(1, 2, 3);
    }
}
```

### **Subgroup support**

[@Firestar99](https://github.com/firestar99) also added support for subgroups via
[subgroup intrinsics](https://github.com/Rust-GPU/rust-gpu/pull/14).

[Subgroups](https://www.khronos.org/blog/vulkan-subgroup-tutorial) allow a group of
threads of vendor-defined size to share data and perform synchronized operations more
efficiently. For example, using subgroup intrinsics you can:

- Perform reductions (e.g., sum, min, max) across threads in a subgroup.
- Share intermediate results without relying on global memory, reducing latency.
- Implement algorithms like prefix sums or parallel sorting more effectively.

## Added `TypedBuffer`

[@eddyb](https://github.com/eddyb) and [@Firestar99](https://github.com/firestar99)
[introduced `TypedBuffer`](https://github.com/Rust-GPU/rust-gpu/pull/16), an explicit
way to declare inputs and outputs as buffers. This enables declaring an "array of buffer
descriptors containing something" as is common in
[bindless](https://computergraphics.stackexchange.com/questions/10794/binding-vs-bindless).

Here is an example of using
[`TypedBuffer`](https://rust-gpu.github.io/rust-gpu/api/spirv_std/struct.TypedBuffer.html)
in a fragment shader:

```rust
use glam::Vec4;
use spirv_std::TypedBuffer;
use spirv_std::spirv;

#[spirv(fragment)]
pub fn main(
    #[spirv(storage_buffer, descriptor_set = 0, binding = 0)] single: &TypedBuffer<Vec4>,
    #[spirv(storage_buffer, descriptor_set = 0, binding = 1)] single_mut: &mut TypedBuffer<Vec4>,
) {
    **single_mut = **single;
}
```

### Read-only buffer support for `ByteAddressableBuffer`

Thanks to [@Firestar99](https://github.com/firestar99),
[`ByteAddressableBuffer`](https://rust-gpu.github.io/rust-gpu/api/spirv_std/byte_addressable_buffer/struct.ByteAddressableBuffer.html)
now supports [reading from read-only
buffers](https://github.com/Rust-GPU/rust-gpu/pull/17). Previously the buffers needed to
be read-write. Using read-only buffers can improve performance for immutable data.

### Dependency updates

We updated key GPU dependencies like [`glam`](https://github.com/bitshifter/glam-rs).
One of the unique benefits of Rust on the GPU is that we use the exact `glam` crate from
[crates.io](https://crates.io/crates/glam), so this was a simple `Cargo.toml` update.

Additionally, examples now use the latest versions of CPU-side crates such as
[`ash`](https://github.com/ash-rs/ash) and [`wgpu`](https://github.com/gfx-rs/wgpu).

## Other related changes

### SPIR-V atomics in `wgpu`

Rust GPU maintainer [@schell](https://github.com/schell) added [SPIR-V atomic support to
`wgpu`](https://github.com/gfx-rs/wgpu/issues/4489). This was part of his work on
[`renderling`](https://github.com/schell/renderling), a project built with Rust GPU. The
change enables Rust GPU programs to use atomics and integrate with CPU-side code managed
by [`wgpu`](https://github.com/gfx-rs/wgpu). Funding came from a grant by
[NLnet](https://nlnet.nl/).

### Rustlantis integration

[@FractalFir](https://github.com/FractalFir) created
[`rustc_codegen_clr`](https://github.com/FractalFir/rustc_codegen_clr), an experimental
Rust compiler backend that converts Rust into .NET assemblies or C source files. He
adapted [Rustlantis](https://github.com/cbeuw/rustlantis), a MIR fuzzer for generating
complex test programs, to support his project.

When Rust GPU maintainers asked if the changes could help Rust GPU,
[`@FractalFir`](https://github.com/FractalFir) took the extra step of updating his
Rustlantis fork to support it as well. This collaboration has already uncovered three
issues in Rust GPU. We plan to continue investing in Rustlantis support to improve
automated testing and actively hunt for bugs.

### New website

Rust GPU maintainer [@LegNeato](https://github.com/LegNeato) added a [new website for
the project](https://rust-gpu.github.io/) using [Docusaurus](https://docusaurus.io/). He
also created some Docusaurus
[plugins](https://github.com/Rust-GPU/rust-gpu.github.io/tree/main/src/plugins) and
[components](https://github.com/Rust-GPU/rust-gpu.github.io/tree/main/src/components/Snippet)
to better support the project's needs. Finally, he wrote a blog post about [optimizing a
Rust GPU matmul kernel](/blog/optimizing-matmul) that was popular on
[Reddit](https://www.reddit.com/r/rust/comments/1gzmchn/optimizing_a_rust_gpu_matmul_kernel/)
and [Hacker News](https://news.ycombinator.com/item?id=42280697).

## Community

Thank you to the 13 community contributors, most of whom contributed for the first time:

[BeastLe9enD](https://github.com/BeastLe9enD), [beef
(`@fee1-dead`)](https://github.com/fee1-dead), [Brice Videau
(`@Kerilk`)](https://github.com/Kerilk) [Bruce Mitchener
(`@waywardmonkeys`)](https://github.com/waywardmonkeys),
[`@FractalFir`](https://github.com/FractalFir), [Fredrik Fornwall
(`@fornwall`)](https://github.com/fornwall), [Gray Olson
(`@fu5ha`)](https://github.com/fu5ha), [Jake Shadle](https://github.com/Jake-Shadle),
[Léo Gaspard (`@Ekleog`)](https://github.com/Ekleog), [Rowan Jones
(`@ArrEssJay`)](https://github.com/ArrEssJay), [Marek Bernat
(`@mbernat`)](https://github.com/mbernat), [Viktor Zoutman
(`@VZout`)](https://github.com/VZout), [`@Zanciks`](https://github.com/zanciks)

We're especially grateful that [`@Zanciks`](https://github.com/Zanciks) chose Rust GPU for
their first ever open source contribution!

## Maintainers

As [previously announced](/blog/transition-announcement), Rust GPU has four active
maintainers who contributed to this release (in alphabetical order):

1. [Christian Legnitto (LegNeato)](https://github.com/LegNeato)
2. [Eduard-Mihai Burtescu (eddyb)](https://github.com/eddyb)
3. [Firestar99](https://github.com/firestar99)
4. [Schell Carl Scivally (schell)](https://github.com/schell)

<br/>

We're always looking for active contributors to become new maintainers. [Join us](https://github.com/rust-gpu/rust-gpu) and make an impact!
