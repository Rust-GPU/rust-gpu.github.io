{"allContent":{"docusaurus-plugin-content-docs":{"default":{"loadedVersions":[{"versionName":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","path":"/docs","tagsPath":"/docs/tags","isLast":true,"routePriority":-1,"contentPath":"/Users/legnitto/src/rust-gpu.github.io/docs","contentPathLocalized":"/Users/legnitto/src/rust-gpu.github.io/i18n/en/docusaurus-plugin-content-docs/current","docs":[{"id":"empty","title":"empty","description":"","source":"@site/docs/empty.md","sourceDirName":".","slug":"/empty","permalink":"/docs/empty","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar"}],"drafts":[],"sidebars":{"defaultSidebar":[{"type":"doc","id":"empty"}]}}]}},"docusaurus-plugin-content-blog":{"default":{"blogSidebarTitle":"Recent posts","blogPosts":[{"id":"transition-announcement","metadata":{"permalink":"/blog/transition-announcement","editUrl":"https://github.com/Rust-GPU/rust-gpu.github.io/tree/main/blog/2024-08-12-transition-announcement.md","source":"@site/blog/2024-08-12-transition-announcement.md","title":"Rust GPU Transitions to Community Ownership","description":"We are excited to announce that as of today the <a","date":"2024-08-12T00:00:00.000Z","tags":[{"inline":false,"label":"announcement","permalink":"/blog/tags/announcements","description":"Announcements"}],"readingTime":7.75,"hasTruncateMarker":true,"authors":[{"name":"Christian Legnitto","title":"Rust GPU maintainer","url":"https://github.com/LegNeato","socials":{"x":"https://x.com/LegNeato","github":"https://github.com/LegNeato"},"imageURL":"/img/authors/LegNeato.png","key":"LegNeato","page":null},{"name":"EddyB","title":"Rust GPU maintainer","socials":{"github":"https://github.com/eddyb"},"imageURL":"/img/authors/eddyb.png","key":"eddyb","page":null}],"frontMatter":{"title":"Rust GPU Transitions to Community Ownership","authors":["LegNeato","eddyb"],"slug":"transition-announcement","tags":["announcement"]},"unlisted":false},"content":"We are excited to announce that as of today the <a\nhref=\"https://rust-gpu.github.io\">Rust GPU</a> project will be transitioning from\n[Embark Studios](https://www.embark-studios.com/) to community ownership under the [Rust\nGPU GitHub organization](https://github.com/rust-gpu/rust-gpu). This move marks the\nbeginning of a broader strategy aimed at revitalizing, unifying, and standardizing GPU\nprogramming in Rust. We are eager to share more details in the near future but in the\nmeantime if you are a maintainer of a GPU-related Rust project, please reach out!\n\n<!-- truncate -->\n\n## What is Rust GPU?\n\n<a href=\"https://rust-gpu.github.io\">Rust GPU</a> makes it possible to write and run GPU\nsoftware in Rust, leveraging the language's powerful safety and concurrency features to\nenhance performance and reliability. With Rust GPU, you can seamlessly develop for both\nCPU and GPU using a unified codebase, all while benefiting from Rust’s existing\necosystem.\n\nThe Rust GPU compiler backend emits code compatible with\n[Vulkan](https://www.vulkan.org), ensuring your code runs across a wide range of devices\nand vendors.\n\nIf instead you wish to stick to the NVIDIA ecosystem, stay tuned as the [Rust\nCUDA](https://github.com/rust-gpu/rust-cuda) project is in the process of being rebooted\nand possibly integrated with Rust GPU.\n\nTo put Rust GPU in context, here's an overview of the current landscape:\n\n- **[rust-gpu](https://github.com/EmbarkStudios/rust-gpu)**: Compiles unmodified Rust\n  code to [SPIR-V](https://www.khronos.org/spir/) (Vulkan) so that it can run on the\n  GPU.\n- **[rust-cuda](https://github.com/Rust-GPU/Rust-CUDA)**: Compiles unmodified Rust code\n  to [NVVM](https://docs.nvidia.com/cuda/nvvm-ir-spec/index.html) (CUDA) so that it can\n  run on the GPU. _Currently unmaintained but stay tuned!_\n- **[nvptx backend in rustc](https://doc.rust-lang.org/rustc/platform-support/nvptx64-nvidia-cuda.html)**: Compiles unmodified Rust code to [PTX](https://docs.nvidia.com/cuda/parallel-thread-execution/index.html) (CUDA) so that it can run on the GPU.\n- **[CubeCL](https://github.com/tracel-ai/cubecl)**: Compute language extension for Rust. Enables annotated Rust code to run on the GPU.\n- **[krnl](https://github.com/charles-r-earp/krnl)**: Safe, portable, high performance compute (GPGPU) kernels. Enables annotated Rust code to run on the GPU (via Rust GPU).\n- **[cudarc](https://github.com/coreylowman/cudarc)**: Minimal and safe api over the CUDA toolkit. Enables calling CUDA from Rust running on the CPU.\n- **[wgpu](https://wgpu.rs/)**: A safe and portable graphics library for Rust based on the WebGPU API. Enables communicating with the GPU from Rust running on the CPU.\n- **[naga](https://github.com/gfx-rs/wgpu/tree/trunk/naga)**: A source code translator written in Rust that converts between various GPU-specific shader languages ([WGSL](https://www.w3.org/TR/WGSL/)**, **[GLSL](https://en.wikipedia.org/wiki/OpenGL_Shading_Language), [HLSL](https://en.wikipedia.org/wiki/High-Level_Shader_Language), and [MSL](https://developer.apple.com/metal/)). These shaders ultimately run on the GPU.\n- **[ZLUDA](https://github.com/vosen/ZLUDA)**: A drop-in replacement for CUDA written in Rust. Enables using tools and libraries targeted at CUDA on non-NVIDIA hardware.\n- **[Asahi Linux GPU drivers](https://asahilinux.org/2022/12/gpu-drivers-now-in-asahi-linux/)**: GPU drivers partially written in Rust to add Linux support for Apple GPUs.\n\n## Why Rust for GPU Programming?\n\n1. **Modern and Unified Experience:** There is no longer a need to learn a GPU-specific\n   programming language. You can write both CPU and GPU code in Rust, leveraging your\n   existing Rust knowledge and maintaining a consistent development experience.\n   Furthermore, the _same code can run on both the CPU and GPU_, with divergent behavior\n   gated behind `cfg` attributes and macros where necessary.\n\n   Even if your current codebase isn't written in Rust, choosing Rust for the GPU parts\n   instead of GPU-specific languages gives you more widely applicable skills in one of\n   the [fastest-growing languages on\n   GitHub](https://octoverse.github.com/2022/top-programming-languages). Rust is also\n   one of the [most admired programming\n   languages](https://github.blog/developer-skills/programming-languages-and-frameworks/why-rust-is-the-most-admired-language-among-developers/)\n   while GPU-specific languages are considered a necessary evil.\n\n2. **Fearless Concurrency:** Rust's ownership model and type system guarantee memory\n   safety, minimizing bugs and undefined behavior. Rust's borrow checker also enables\n   fearless concurrency, which is essential for maximizing performance on massively\n   parallel GPUs.\n\n3. **Powerful Abstractions:** Programming in GPU-specific languages can often feel like\n   [taking a step back to the 90s](https://xol.io/blah/death-to-shading-languages/),\n   where primitive tools and sharp edges abound. Because of this, code written for GPUs\n   is simplistic with low cyclomatic complexity. Rust has an expressive type system and\n   zero-cost abstractions that enable writing high-level, reusable code without\n   sacrificing performance. This approach leads to more maintainable and sophisticated\n   GPU programs, streamlining the development process and enhancing productivity.\n\n4. **Leverage Existing Ecosystem:** The state-of-the-art for sharing GPU code is copy\n   and pasting. With Rust GPU we are excited to bring the excellent `cargo` and\n   crates.io ecosystem to GPU programming and provide some sanity.\n\n   Additionally, Rust's `no_std` ecosystem offers a wide array of libraries that can be\n   used in environments without the standard library. Traditionally this has meant\n   embedded devices, but a lot of the same assumptions apply to GPUs! As a\n   consequence, you can reuse [existing `no_std` libraries from\n   crates.io](https://crates.io/categories/no-std::no-alloc) in your GPU code _without\n   the authors explicitly adding GPU support_. This is uniquely enabled by Rust GPU's\n   implementation choices and Rust's\n   [registers](https://without.boats/blog/the-registers-of-rust/). Sharing and reusing\n   code from the greater Rust ecosystem is a superpower when writing GPU programs that\n   will massively compound over time.\n\n   Soon developers will write and share Rust libraries that _require_ running on the\n   GPU, similar to how some existing open source libraries require a specific OS or CPU\n   architecture. We expect many innovative GPU-specific algorithms and projects to be\n   built in Rust.\n\n## A Heartfelt Thank You to Embark\n\nFirst and foremost, we extend our deepest gratitude to [Embark\nStudios](https://www.embark-studios.com/) for their incredible work in kickstarting and\nsupporting the Rust GPU project. Their dedication and contributions have been\ninvaluable, laying a strong foundation for the future. The community is immensely\ngrateful for all the resources and expertise Embark has poured into this project.\n\n## Transition Challenges: Repository Transfer\n\nUnfortunately, Embark has decided not to transfer the existing repository via [GitHub's\ntransfer\ntool](https://docs.github.com/en/repositories/creating-and-managing-repositories/transferring-a-repository),\nwhich means we will lose all our stars, issues, and pull requests. Additionally,\nautomatic GitHub redirects will not be added. All this causes avoidable churn.\n\nWe have not fully transitioned to the new community-owned repository due to these\ndownsides and we believe the best course of action is to encourage Embark to reconsider\nand simply press the GitHub transfer button, easing this transition for everyone\ninvolved. We appreciate the community's patience and understanding as we get things\nsorted out and we'd love your support encouraging Embark to reconsider the mechanics of\nthe transfer.\n\n## New Focus: GPU Compute and GPGPU\n\nWith the industry's growing emphasis on generative AI and LLMs, we are shifting our\nprimary focus towards GPU compute and General-Purpose GPU (GPGPU) programming. This also\naligns with the trend in GPU hardware to increasingly utilize the compute capabilities\nof GPUs to run graphics pipelines as software libraries rather than relying on\nspecialized hardware. Even graphics-focused programs such as video games are moving away\nfrom solely relying on graphics pipelines and instead running as much of the engine as\npossible in GPU compute.\n\nIn the past, the primary focus on graphics use-cases did not materialize the necessary\ncontributors and community engagement to make the Rust GPU project sustainable. We hope\nour new focus will attract more contributors and users.\n\nHowever, it is important to note that graphics use-cases will continue to be supported,\ndeveloped, and improved in Rust GPU! We appreciate our early graphics adopters and\nremain committed to enhancing the graphics capabilities of Rust GPU.\n\n## Addressing Stability and Nightly Rust\n\nThough Rust GPU requires the nightly version of Rust, Embark had unique stability goals\nwhich resulted in Rust GPU not tracking the _latest_ nightly. This has been a hurdle for\nadoption, as most people experimenting with Rust GPU are likely already on nightly to\nget the latest and greatest, not use a randomly chosen nightly from months ago. To\naddress this, we will be tracking the latest Rust nightly builds moving forward. For\nthose concerned about stability, you can pin to a particular nightly version via <a\nhref=\"https://rust-lang.github.io/rustup/overrides.html#the-toolchain-file\">`rust-toolchain`</a>,\nand there are ways to build your GPU code with nightly while keeping your CPU code on\nstable.\n\nWith today's release we are closer to this goal but we aren't quite tracking the latest\nnightly yet as some newer `rustc` changes require more substantial changes to Rust GPU's\ncompiler backend.\n\n## Short-Term Roadmap\n\nOur immediate focus is on the following tasks:\n\n- **Merge all outstanding work.**\n- **Track the latest Rust nightly.** Stay up-to-date with the latest developments in\n  Rust and catch changes that break Rust GPU's compiler backend as soon as they land\n  upstream.\n- **Release more often.** Increase our release cadence to deliver improvements and fixes\n  more frequently, as well as aid in debugging issues.\n- **Extend/update documentation, FAQ, and guides.** Provide solutions to common problems\n  and usage scenarios and document unsupported language constructs.\n- **Better compatibility.**\n  - Fully switch to [quasi-pointers](https://github.com/EmbarkStudios/spirt/pull/24) to\n    support more advanced Rust constructs.\n  - Add `alloc` support. This will allow us to use even more `no_std` crates that also allocate memory.\n- **Better testing.**\n  - Develop our own crater-like tool to create a burndown list of `no_std` and `alloc`\n    crates that don't work with Rust GPU.\n  - Implement a differential testing harness.\n  - Establish ecosystem CI similar to the [SWC\n    project](https://github.com/swc-project/swc/tree/main/.github/swc-ecosystem-ci).\n\n## Long-Term Vision: First-Class GPU Targets in Rust\n\nLooking further ahead, one of our ambitious goals is to merge Rust GPU or its successor\ninto the Rust compiler itself. We want to make GPUs (and TPUs and NPUs) first-class\ntargets in Rust and make programming them as ergonomic as CPU programming. **Hardware is\nshifting from scalar, serial processing to matrix, parallel processing—software must do\nthe same.** We are excited about the future of Rust GPU and the potential it holds.\n\nThank you for your continued support and contributions. Stay tuned for more updates, and\ndon't hesitate to reach out if you have any questions or want to get involved.\n\nHappy coding!"}],"blogListPaginated":[{"items":["transition-announcement"],"metadata":{"permalink":"/blog","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"blogTags":{"/blog/tags/announcements":{"inline":false,"label":"announcement","permalink":"/blog/tags/announcements","description":"Announcements","items":["transition-announcement"],"pages":[{"items":["transition-announcement"],"metadata":{"permalink":"/blog/tags/announcements","page":1,"postsPerPage":10,"totalPages":1,"totalCount":1,"blogDescription":"Blog","blogTitle":"Blog"}}],"unlisted":false}},"blogTagsListPath":"/blog/tags","authorsMap":{"LegNeato":{"name":"Christian Legnitto","title":"Rust GPU maintainer","url":"https://github.com/LegNeato","socials":{"x":"https://x.com/LegNeato","github":"https://github.com/LegNeato"},"imageURL":"/img/authors/LegNeato.png","key":"LegNeato","page":null},"eddyb":{"name":"EddyB","title":"Rust GPU maintainer","socials":{"github":"https://github.com/eddyb"},"imageURL":"/img/authors/eddyb.png","key":"eddyb","page":null}}}},"docusaurus-plugin-content-pages":{"default":[{"type":"mdx","permalink":"/changelog","source":"@site/src/pages/changelog.md","title":"Changelog","description":"All notable changes to this project will be documented in this file.","frontMatter":{"id":"changelog","title":"Changelog","sidebar_label":"Changelog"},"unlisted":false},{"type":"mdx","permalink":"/ecosystem","source":"@site/src/pages/ecosystem.md","title":"Ecosystem","description":"The GPU ecosystem in Rust is nascent and complex. It can be challenging to understand","frontMatter":{"title":"Ecosystem"},"unlisted":false},{"type":"jsx","permalink":"/","source":"@site/src/pages/index.tsx"},{"type":"mdx","permalink":"/markdown-page","source":"@site/src/pages/markdown-page.md","title":"Markdown page example","description":"You don't need React to write simple standalone pages.","frontMatter":{"title":"Markdown page example"},"unlisted":false}]},"docusaurus-plugin-debug":{},"docusaurus-theme-classic":{},"fetch-author-images-plugin":{},"fetch-changelog-plugin":{},"docusaurus-tailwindcss":{},"docusaurus-bootstrap-plugin":{},"docusaurus-mdx-fallback-plugin":{}}}